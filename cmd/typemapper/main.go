package main

import (
	"fmt"
	"go/types"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/go/ssa"
)

func main() {
	err := mainErr()
	if err != nil {
		log.Fatal(err)
	}
}

func mainErr() error {
	cfg := &packages.Config{
		Mode:       packages.LoadSyntax,
		BuildFlags: []string{"-tags", "typemapper"},
		Tests:      false,
	}
	pkgs, err := packages.Load(cfg, "./")
	if err != nil {
		return err
	}
	if len(pkgs) != 1 {
		return errors.Errorf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0]

	prog := ssa.NewProgram(pkg.Fset, ssa.BuilderMode(0))

	// Create SSA packages for all imports.
	// Order is not significant.
	created := make(map[*types.Package]bool)
	var createAll func(pkgs []*types.Package)
	createAll = func(pkgs []*types.Package) {
		for _, p := range pkgs {
			if !created[p] {
				created[p] = true
				prog.CreatePackage(p, nil, nil, true)
				createAll(p.Imports())
			}
		}
	}
	createAll(pkg.Types.Imports())

	// Create and build the primary package.
	ssapkg := prog.CreatePackage(pkg.Types, pkg.Syntax, pkg.TypesInfo, false)
	ssapkg.Build()

	//ssapkg.WriteTo(os.Stdout)

	g := &generator{
		File: jen.NewFile(pkg.Name),

		typesPkg: pkg.Types,
	}
	g.HeaderComment(fmt.Sprintf("// Code generated by \"typemapper %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " ")))
	g.HeaderComment("// +build !typemapper")

	for _, mem := range ssapkg.Members {
		switch mem := mem.(type) {
		case *ssa.Type:
			for _, ms := range []*types.MethodSet{
				prog.MethodSets.MethodSet(mem.Type()),
				prog.MethodSets.MethodSet(types.NewPointer(mem.Type())),
			} {
				for i := 0; i < ms.Len(); i++ {
					sel := ms.At(i)
					ssaF := prog.MethodValue(sel)
					err := g.mapFunction(ssaF)
					if err != nil {
						return err
					}
				}
			}
		case *ssa.Function:
			err := g.mapFunction(mem)
			if err != nil {
				return err
			}
		}
	}

	outFile, err := os.OpenFile("typemapper.generated.go", os.O_RDWR|os.O_CREATE, 0664)
	if err != nil {
		return err
	}
	defer outFile.Close()

	err = g.Render(outFile)
	if err != nil {
		return err
	}

	return nil
}

type generator struct {
	*jen.File

	typesPkg *types.Package
}

func (g *generator) mapFunction(f *ssa.Function) error {
	// f.WriteTo(os.Stdout)

	mapCall := findTypeMapperCreateMapCall(f)
	if mapCall == nil {
		return nil
	}

	if len(f.Blocks) > 1 {
		return errors.Errorf("one block expected in mapping function, found %d", len(f.Blocks))
	}

	results := mapCall.Common().Signature().Results()

	// TODO: allow for returning dst? src?
	if results.Len() > 1 {
		return errors.Errorf("expected zero or one function result, found %d", results.Len())
	}
	if results.Len() == 1 {
		errResult := results.At(0)
		n, ok := errResult.Type().(*types.Named)
		if !ok {
			return errors.Errorf("expected return type to be a *types.Named, got %T", errResult.Type())
		}
		if n.String() != "error" {
			return errors.Errorf("expected return type to be an error, got %s", n.String())
		}
	}

	block := f.Blocks[0]

	src := mapCall.Common().Args[0]
	srcI, ok := src.(ssa.Instruction)
	if !ok {
		return errors.Errorf("unable to convert source to instruction (%T)", src)
	}

	dst := mapCall.Common().Args[1]
	dstI, ok := dst.(ssa.Instruction)
	if !ok {
		return errors.Errorf("unable to convert destination to instruction (%T)", dst)
	}

	for _, inst := range block.Instrs {
		if inst == srcI ||
			inst == dstI ||
			inst == mapCall {
			continue
		}
		switch inst := inst.(type) {
		default:
			//return errors.Errorf("unexpected instruction in function body %T", inst)
			// ignore instruction
		case ssa.CallInstruction:
			if !isTypeMapperCall(inst) {
				return errors.Errorf("unexpected call in function body %T", inst)
			}

			callF, ok := inst.Common().Value.(*ssa.Function)
			if !ok {
				return errors.Errorf("unexpected typemapper call in function body %T", inst)
			}

			switch callF.Name() {
			default:
				return errors.Errorf("unexpected typemapper call in function body %T", inst)
			case "RecognizePrefixes":
				
			}
		case *ssa.Return:
			for _, res := range inst.Results {
				switch res := res.(type) {
				case *ssa.Const:
					if !res.IsNil() {
						return errors.Errorf("expected a nil return value")
					}
				}
			}
		}
	}

	srcP, err := param(src)
	if err != nil {
		return err
	}
	dstP, err := param(dst)
	if err != nil {
		return err
	}

	return g.generateTypeMapping(f.Name(), f.Signature, srcP, dstP)
}

func param(v ssa.Value) (*ssa.Parameter, error) {
	switch v := v.(type) {
	case *ssa.Parameter:
		return v, nil
	case *ssa.MakeInterface:
		return param(v.X)
	}
	return nil, errors.Errorf("unexpected value %T %#v", v, v)
}

func findTypeMapperCreateMapCall(f *ssa.Function) ssa.CallInstruction {
	for _, b := range f.Blocks {
		for _, inst := range b.Instrs {
			switch inst := inst.(type) {
			case ssa.CallInstruction:
				if !isTypeMapperCall(inst) {
					continue
				}

				callF, ok := inst.Common().Value.(*ssa.Function)
				if !ok {
					continue
				}

				if callF.Name() != "CreateMap" {
					continue
				}
				return inst
			}
		}
	}
	return nil
}

func isTypeMapperCall(inst ssa.CallInstruction) bool {
	callF, ok := inst.Common().Value.(*ssa.Function)
	if !ok {
		return false
	}
	if !strings.HasSuffix(callF.Pkg.Pkg.Path(), "github.com/paultyng/go-typemapper") {
		return false
	}
	return true
}