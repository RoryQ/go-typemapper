package main

import (
	"fmt"
	"go/types"
	"log"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/go/ssa"

	"github.com/paultyng/go-typemapper/mapper"
)

func main() {
	err := mainErr()
	if err != nil {
		log.Fatal(err)
	}
}

func mainErr() error {
	cfg := &packages.Config{
		Mode:       packages.LoadSyntax,
		BuildFlags: []string{"-tags", "typemapper"},
		Tests:      false,
	}
	pkgs, err := packages.Load(cfg, "./")
	if err != nil {
		return err
	}
	if len(pkgs) != 1 {
		return errors.Errorf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0]

	prog := ssa.NewProgram(pkg.Fset, ssa.BuilderMode(0))

	// Create SSA packages for all imports.
	// Order is not significant.
	created := make(map[*types.Package]bool)
	var createAll func(pkgs []*types.Package)
	createAll = func(pkgs []*types.Package) {
		for _, p := range pkgs {
			if !created[p] {
				created[p] = true
				prog.CreatePackage(p, nil, nil, true)
				createAll(p.Imports())
			}
		}
	}
	createAll(pkg.Types.Imports())

	// Create and build the primary package.
	ssapkg := prog.CreatePackage(pkg.Types, pkg.Syntax, pkg.TypesInfo, false)
	ssapkg.Build()

	//ssapkg.WriteTo(os.Stdout)

	g := &generator{
		File: jen.NewFile(pkg.Name),

		typesPkg: pkg.Types,
	}
	g.HeaderComment(fmt.Sprintf("// Code generated by \"typemapper %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " ")))
	g.HeaderComment("// +build !typemapper")

	for _, mem := range ssapkg.Members {
		switch mem := mem.(type) {
		case *ssa.Type:
			for _, ms := range []*types.MethodSet{
				prog.MethodSets.MethodSet(mem.Type()),
				prog.MethodSets.MethodSet(types.NewPointer(mem.Type())),
			} {
				for i := 0; i < ms.Len(); i++ {
					sel := ms.At(i)
					ssaF := prog.MethodValue(sel)
					err := g.mapFunction(ssaF)
					if err != nil {
						return err
					}
				}
			}
		case *ssa.Function:
			err := g.mapFunction(mem)
			if err != nil {
				return err
			}
		}
	}

	outFile, err := os.OpenFile("typemapper.generated.go", os.O_RDWR|os.O_CREATE, 0664)
	if err != nil {
		return err
	}
	defer outFile.Close()

	err = g.Render(outFile)
	if err != nil {
		return err
	}

	return nil
}

type generator struct {
	*jen.File

	typesPkg *types.Package
}

func (g *generator) mapFunction(f *ssa.Function) error {
	// f.WriteTo(os.Stdout)

	if len(f.Blocks) > 1 {
		return errors.Errorf("one block expected in mapping function, found %d", len(f.Blocks))
	}

	var (
		m    *mapper.StructMapper
		srcP *ssa.Parameter
		dstP *ssa.Parameter
		err  error
	)

	for _, inst := range f.Blocks[0].Instrs {
		switch inst := inst.(type) {
		case ssa.CallInstruction:
			if !isTypeMapperCall(inst) {
				continue
			}
			callF, ok := inst.Common().Value.(*ssa.Function)
			if !ok {
				return errors.Errorf("expected *ssa.Function, got %T", inst.Common().Value)
			}

			if m == nil {
				if callF.Name() != "CreateMap" {
					return errors.Errorf("expected call to CreateMap, but got %s", callF.Name())
				}
				m, err = handleCreateMap(inst)
				if err != nil {
					return err
				}
			}

			// TODO: do this via map of funcs?
			switch callF.Name() {
			default:
				return errors.Errorf("unexpected typemapper call %s", callF.Name())
			case "RecognizePrefixes":
				err = handleRecognizePrefixes(m, inst)
				if err != nil {
					return err
				}
			case "MapField":
				err = handleMapField(m, inst)
				if err != nil {
					return err
				}
			case "IgnoreFields":
				err = handleIgnoreFields(m, inst)
				if err != nil {
					return err
				}
			}
		}
	}

	return g.generateTypeMapping(f.Name(), f.Signature, srcP, dstP, m)
}

func handleMapField(m *mapper.StructMapper, call ssa.CallInstruction) error {
	// TODO
	return nil
}

func handleRecognizePrefixes(m *mapper.StructMapper, call ssa.CallInstruction) error {
	// TODO
	return nil
}

func handleIgnoreFields(m *mapper.StructMapper, call ssa.CallInstruction) error {
	// TODO
	return nil
}

func handleCreateMap(call ssa.CallInstruction) (*mapper.StructMapper, error) {
	src := call.Common().Args[0]
	srcP, err := param(src)
	if err != nil {
		return nil, err
	}
	dst := call.Common().Args[1]
	dstP, err := param(dst)
	if err != nil {
		return nil, err
	}

	m := mapper.NewStructMapper(srcP.Type(), dstP.Type())
	return m, nil
}

func param(v ssa.Value) (*ssa.Parameter, error) {
	switch v := v.(type) {
	case *ssa.Parameter:
		return v, nil
	case *ssa.MakeInterface:
		return param(v.X)
	}
	return nil, errors.Errorf("unexpected value %T %#v", v, v)
}

func isTypeMapperCall(inst ssa.CallInstruction) bool {
	callF, ok := inst.Common().Value.(*ssa.Function)
	if !ok {
		return false
	}
	if !strings.HasSuffix(callF.Pkg.Pkg.Path(), "github.com/paultyng/go-typemapper") {
		return false
	}
	return true
}
